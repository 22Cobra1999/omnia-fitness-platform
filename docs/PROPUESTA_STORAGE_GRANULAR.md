# üéØ Propuesta: Tracking Granular de Archivos en Storage

## ‚ö†Ô∏è Problema Actual

La tabla `storage_usage` actual agrupa **todo** por concepto (video/image/pdf) y luego lista **todas** las actividades del coach, incluso si no usan ese archivo espec√≠fico.

### Ejemplo del Bug:

```sql
-- Esto est√° MAL
INSERT INTO storage_usage VALUES
  (1, 'coach-123', 'video', 0.032, '[90, 59, 48, 78]', ...)
```

**Problema:** Dice que las actividades 90, 59, 48 y 78 usan videos, pero en realidad:
- Video 1 solo lo usa actividad 90
- Video 2 solo lo usa actividad 59
- etc.

---

## üéØ Soluci√≥n Recomendada: Opci√≥n A - Nueva Tabla `storage_files`

Crear una tabla que rastrea **cada archivo individual** y d√≥nde se usa.

### Estructura:

```sql
CREATE TABLE storage_files (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  coach_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- Identificaci√≥n del archivo
  concept TEXT NOT NULL CHECK (concept IN ('video', 'image', 'pdf', 'other')),
  file_id TEXT NOT NULL, -- Para videos: bunny_video_id, para archivos: UUID o path
  file_name TEXT, -- Nombre descriptivo del archivo
  file_url TEXT, -- URL completa del archivo
  
  -- Metadata del archivo
  size_bytes BIGINT NOT NULL, -- Tama√±o en bytes
  gb_usage DECIMAL(12, 6) GENERATED ALWAYS AS (size_bytes / 1073741824.0) STORED,
  
  -- D√≥nde se usa
  usage_type TEXT NOT NULL CHECK (usage_type IN ('activity_media', 'ejercicios_detalles', 'nutrition_program_details')),
  reference_id BIGINT NOT NULL, -- ID en la tabla de origen
  activity_id BIGINT NOT NULL REFERENCES activities(id), -- Qu√© actividad lo usa
  
  -- Metadata temporal
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Combinaci√≥n √∫nica: mismo archivo puede estar en m√∫ltiples lugares
  UNIQUE(coach_id, concept, file_id, usage_type, reference_id)
);

-- √çndices
CREATE INDEX idx_storage_files_coach_id ON storage_files(coach_id);
CREATE INDEX idx_storage_files_concept ON storage_files(concept);
CREATE INDEX idx_storage_files_activity_id ON storage_files(activity_id);
CREATE INDEX idx_storage_files_file_id ON storage_files(file_id);
```

### Ejemplo de Datos:

```sql
-- Video 1 usado en actividad 90
INSERT INTO storage_files VALUES
  (1, 'coach-123', 'video', 'bunny-video-aaa-111', 'Clase de Yoga.mp4', 
   'https://iframe.mediadelivery.net/embed/bunny-video-aaa-111',
   15728640, -- 15 MB
   'activity_media', 1, 90, NOW(), NOW());

-- Video 1 usado en actividad 90 (otra referencia - puede pasar si est√° duplicado)
INSERT INTO storage_files VALUES
  (2, 'coach-123', 'video', 'bunny-video-aaa-111', 'Clase de Yoga.mp4',
   'https://iframe.mediadelivery.net/embed/bunny-video-aaa-111',
   15728640, -- 15 MB (se cuenta solo UNA vez si mismo video_id)
   'activity_media', 2, 90, NOW(), NOW());

-- Video 2 usado en actividad 59
INSERT INTO storage_files VALUES
  (3, 'coach-123', 'video', 'bunny-video-bbb-222', 'Ejercicio Cardio.mp4',
   'https://iframe.mediadelivery.net/embed/bunny-video-bbb-222',
   15728640, -- 15 MB
   'activity_media', 3, 59, NOW(), NOW());

-- Imagen usada en actividad 48
INSERT INTO storage_files VALUES
  (4, 'coach-123', 'image', 'image-abc-123', 'banner-actividad.jpg',
   'https://supabase.co/storage/v1/object/public/product-media/coaches/coach-123/images/banner.jpg',
   524288, -- 512 KB
   'activity_media', 4, 48, NOW(), NOW());
```

### Consultas √ötiles:

```sql
-- Ver todos los archivos de un coach con sus actividades
SELECT 
  sf.concept,
  sf.file_name,
  sf.gb_usage,
  sf.activity_id,
  a.title as actividad_nombre,
  sf.file_url
FROM storage_files sf
INNER JOIN activities a ON sf.activity_id = a.id
WHERE sf.coach_id = 'coach-123'
ORDER BY sf.concept, sf.gb_usage DESC;

-- Resultado:
-- concept | file_name           | gb_usage  | activity_id | actividad_nombre | file_url
-- ---------|---------------------|-----------|-------------|------------------|--------
-- video    | Clase de Yoga.mp4   | 0.015000  | 90          | Yoga Matutino    | https://...
-- video    | Ejercicio Cardio    | 0.015000  | 59          | Cardio Intenso   | https://...
-- image    | banner-actividad.jpg| 0.000500  | 48          | Entrenamiento... | https://...

-- Ver resumen por concepto (para mantener compatibilidad con storage_usage)
SELECT 
  coach_id,
  concept,
  SUM(gb_usage) as total_gb,
  COUNT(DISTINCT file_id) as archivos_unicos,
  COUNT(DISTINCT activity_id) as actividades_que_usan,
  jsonb_agg(DISTINCT activity_id) as activity_ids -- Array de actividades
FROM storage_files
WHERE coach_id = 'coach-123'
GROUP BY coach_id, concept;

-- Ver qu√© actividades usan un archivo espec√≠fico
SELECT 
  sf.activity_id,
  a.title as actividad_nombre,
  sf.file_name
FROM storage_files sf
INNER JOIN activities a ON sf.activity_id = a.id
WHERE sf.file_id = 'bunny-video-aaa-111';

-- Ver archivos hu√©rfanos (archivos que no est√°n en ninguna actividad activa)
SELECT 
  sf.*
FROM storage_files sf
LEFT JOIN activities a ON sf.activity_id = a.id AND a.status = 'active'
WHERE a.id IS NULL;
```

---

## üîÑ Soluci√≥n Alternativa: Opci√≥n B - Mejorar `products` en `storage_usage`

Si no quieres crear una nueva tabla, puedes **arreglar** el c√°lculo de `products` en la tabla actual.

### Cambios Necesarios:

1. **Para Videos:** Ya tienes `videoProductMap` que mapea cada `bunny_video_id` a sus `activity_ids`. Usa eso.
2. **Para Im√°genes:** Consulta `activity_media` donde `image_url IS NOT NULL` y agrupa por archivo.
3. **Para PDFs:** Similar a im√°genes.

### C√≥digo Actualizado:

```typescript
// app/api/coach/storage-usage/route.ts

// Ya tienes esto para videos:
const videoProductMap: Record<string, number[]> = {} // videoId -> [activity_ids]

// Para im√°genes, necesitas similar mapeo:
const imageProductMap: Record<string, number[]> = {} // imageUrl -> [activity_ids]

// Obtener im√°genes con sus actividades
const { data: imageMedia } = await supabase
  .from('activity_media')
  .select('image_url, activity_id')
  .not('image_url', 'is', null)
  .in('activity_id', coachActivityIds)

if (!imageMedia) {
  for (const media of imageMedia) {
    if (!imageProductMap[media.image_url]) {
      imageProductMap[media.image_url] = []
    }
    imageProductMap[media.image_url].push(media.activity_id)
  }
}

// Luego cuando guardas:
if (imageGb > 0) {
  const uniqueImageActivityIds = [...new Set(Object.values(imageProductMap).flat())]
  storageData.push({
    coach_id: user.id,
    concept: 'image',
    gb_usage: parseFloat(imageGb.toFixed(6)),
    products: uniqueImageActivityIds  // ‚úÖ Solo actividades que usan im√°genes
  })
}
```

**Limitaci√≥n:** Esto sigue agregando **todas** las actividades, no te dice qu√© archivo usa qu√© actividad.

---

## üéØ Comparaci√≥n

| Aspecto | Opci√≥n A: `storage_files` | Opci√≥n B: Mejorar `storage_usage` |
|---------|---------------------------|-----------------------------------|
| **Granularidad** | ‚úÖ Por archivo individual | ‚ùå Solo por concepto agregado |
| **Rastreabilidad** | ‚úÖ Sabes qu√© archivo usa qu√© actividad | ‚ùå Solo listas todas las actividades |
| **Archivos hu√©rfanos** | ‚úÖ Puedes encontrar archivos no usados | ‚ùå No puedes |
| **Deduplicaci√≥n** | ‚úÖ Cuentas una vez por archivo √∫nico | ‚ö†Ô∏è Requiere l√≥gica adicional |
| **Migraci√≥n** | ‚ö†Ô∏è Nueva tabla, migrar datos hist√≥ricos | ‚úÖ Solo cambiar c√≥digo |
| **Compatibilidad** | ‚úÖ Mantener `storage_usage` como vista | ‚úÖ Compatible con existente |
| **Performance** | ‚ö†Ô∏è M√°s filas = m√°s datos | ‚úÖ Pocas filas |

---

## üöÄ Recomendaci√≥n

**Usar Opci√≥n A** porque:
1. Te da visibilidad completa
2. Permite encontrar archivos hu√©rfanos
3. Facilita la limpieza manual
4. Puedes mantener `storage_usage` como **vista agregada** para compatibilidad

```sql
-- Crear vista para compatibilidad
CREATE VIEW storage_usage_v2 AS
SELECT 
  coach_id,
  concept,
  SUM(gb_usage) as gb_usage,
  jsonb_agg(DISTINCT activity_id) as products,
  NOW() as created_at,
  MAX(updated_at) as updated_at
FROM storage_files
GROUP BY coach_id, concept;
```

---

## üìã Plan de Implementaci√≥n (Opci√≥n A)

1. **Crear migraci√≥n:**
   ```bash
   db/migrations/YYYYMMDD_create_storage_files_table.sql
   ```

2. **Actualizar API `/api/coach/storage-usage`:**
   - Guardar en `storage_files` en lugar de `storage_usage`
   - O guardar en ambas para compatibilidad

3. **Crear script de migraci√≥n de datos:**
   ```bash
   scripts/migrate-to-storage-files.js
   ```

4. **Actualizar widget de storage:**
   - Mostrar detalle por archivo si es necesario
   - O mantener vista agregada

5. **Agregar cleanup autom√°tico:**
   - Script que elimine registros de archivos eliminados

---

¬øQuieres que implemente la Opci√≥n A o prefieres la Opci√≥n B?






























